# for (int j=0; j<ylen; j++)
#   result = 0;
#   for (int i=0; i<xlen; i++)
#       if (j == i) 
#         result += 2
#       else
#         result += (coeffs[i] * samples[j+i]);
#   results[j] = result;

# Make one SIMD4 invocation of this, equivalent to 4 SIMT threads running (imagine outerloop exists)
# Similar to fir, but add an extra conditional (really a synthetic benchmark)

main {
# useful constants
  zero: int = const 0;
  one: int = const 1;
  two: int = const 2;
  three: int = const 3;
  zerovec: vector = s2vb zero;
  onevec: vector = s2vb one;
  twovec: vector = s2vb two;

# outer loops (vectorizing over)
  j: vector = s2v zero one two three;

# intialize iterators for loop and memory
  inc: vector = s2vb one;

  ci0: vector = s2vb zero;
  si0: vector = s2vb zero;
  sa0: vector = vadd j si0;

  r0: vector = s2vb zero;

# inner loop unrolled twice
# iteration 0
# get mem
  cv1: vector = gather ci0;
  sv1: vector = gather sa0;
# do computation
  p0: pred = vcmp j zerovec;
  (p0) r1p: vector = vadd r0 twovec;
  (!p0) t1: vector = vmul cv1 sv1;
  (!p0) r1n: vector = vadd r0 t1;
  r1: vector = vphi p0 r1p r1n;
# inc mem addresses
  ci1: vector = vadd ci0 one;
  si1: vector = vadd si0 one;
  sa1: vector = vadd j si1;

# iteration 1
# get mem
  cv2: vector = gather ci1;
  sv2: vector = gather sa1;
# do computation
  p1: pred = vcmp j onevec;
  (p1) r2p: vector = vadd r1 twovec;
  (!p1) t2: vector = vmul cv2 sv2;
  (!p1) r2n: vector = vadd r1 t2;
  r2: vector = vphi p1 r2p r1n;

#  scatter r2 
}
